import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import 'package:workshop_management_system/Models/ScheduleModel.dart';
import 'package:firebase_auth/firebase_auth.dart';

class ScheduleController {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  //final _auth = FirebaseAuth.instance;
  //final _db = FirebaseFirestore.instance;

  // Function to fetch all schedules from Firestore (nak display in SelectSchedulePage)
  Stream<List<Schedule>> getSchedules() async* {
    await for (final snapshot
        in _firestore
            .collection('WorkshopSchedule')
            .where('status', isNotEqualTo: 'accepted')
            .snapshots()) {

      final schedules = await Future.wait(
        snapshot.docs.map((doc) async {
          final data = doc.data();
          final workshopOwnerId = data['workshopOwnerId'] as String? ?? '';

          String workshopName = 'Unknown Workshop';

          if (workshopOwnerId.isNotEmpty) {
            final workshopDoc =
                await _firestore
                    .collection('workshop_owner')
                    .doc(workshopOwnerId)
                    .get();

            final workshopData = workshopDoc.data();
            if (workshopData != null && workshopData['workshopName'] != null) {
              workshopName = workshopData['workshopName'] ?? 'Unknown Workshop';
            }
          }

          return Schedule.fromFirestore(doc, workshopName: workshopName);
        }),
      );

      yield schedules;
    }
  }

  // Add new schedule to Firestore
  Future<void> addSchedule(Schedule schedule) async {
    final String uid =
        FirebaseAuth.instance.currentUser!.uid; // Get logged-in foreman UID

    try {
      // Convert Schedule to JSON and add workshopOwnerId
      final scheduleData = schedule.toJson()..['workshopOwnerId'] = uid;

      await _firestore.collection('WorkshopSchedule').add(scheduleData);
      debugPrint('Schedule added successfully');
    } catch (e) {
      debugPrint('Failed to add schedule: $e');
      rethrow;
    }
  }

  // ASSIGN WORKSHOP OWNER ID TO SCHEDULE
  // Delet schedule by id
  Future<void> deleteSchedule(String docId) async {
    try {
      // Deleting by document ID (auto-generated by Firestore)
      await _firestore.collection('WorkshopSchedule').doc(docId).delete();
      debugPrint('Schedule deleted successfully');
    } catch (e) {
      debugPrint('Failed to delete schedule: $e');
      rethrow;
    }
  }

  //function to get the schedule based on the workshop owner id
  Future<Schedule?> getScheduleById(String docId) async {
    final doc =
        await FirebaseFirestore.instance
            .collection('WorkshopSchedule')
            .doc(docId)
            .get();
    if (doc.exists) {
      return Schedule.fromMap(doc.data()!, doc.id);
    }
    return null;
  }

  //function to edit schedule based on id
  Future<void> editSchedule(Schedule schedule) async {
    if (schedule.docId != null) {
      await FirebaseFirestore.instance
          .collection('WorkshopSchedule')
          .doc(schedule.docId)
          .update(schedule.toJson());
    }
  }

  // WAIT FOR FOREMEN USE CASE
  // TUNGGU AINA BUAT FUNCTION NI
  // LATER ASSIGN THE SCHEDULE TO FOREMAN
  Future<void> acceptSchedule(String scheduleDocId) async {
    final String uid =
        FirebaseAuth.instance.currentUser!.uid; // get logged in foreman UID

    try {
      await FirebaseFirestore.instance
          .collection('WorkshopSchedule')
          .doc(scheduleDocId)
          .update({'status': 'accepted', 'foremanId': uid});
    } catch (e) {
      debugPrint('Failed to accept schedule: $e');
    }
  }

  // display the accepeted schedules for foreman
  Stream<List<Schedule>> getAcceptedSchedules(String foremanId) async* {
    await for (final snapshot
        in _firestore
            .collection('WorkshopSchedule')
            .where('status', isEqualTo: 'accepted')
            .where('foremanId', isEqualTo: foremanId)
            .snapshots()) {
      final schedules = await Future.wait(
        snapshot.docs.map((doc) async {
          final data = doc.data();
          final ownerId = data['workshopOwnerId'] as String? ?? '';

          String workshopName = 'Unknown Workshop';

          if (ownerId.isNotEmpty) {
            final ownerDoc =
                await _firestore
                    .collection(
                      'workshop_owner',
                    ) // <-- make sure this matches your actual collection
                    .doc(ownerId)
                    .get();

            final ownerData = ownerDoc.data();
            if (ownerData != null && ownerData['workshopName'] != null) {
              workshopName = ownerData['workshopName'];
            }
          }

          return Schedule.fromFirestore(doc, workshopName: workshopName);
        }),
      );

      yield schedules;
    }
  }

  //fetch all schedules created by workshop owner (Display in ListSchedulePage)
  Stream<List<Schedule>> getSchedulesByOwnerId() {
    final String uid = FirebaseAuth.instance.currentUser!.uid;

    return FirebaseFirestore.instance
        .collection('WorkshopSchedule')
        .where('workshopOwnerId', isEqualTo: uid)
        .snapshots()
        .map((snapshot) {
          return snapshot.docs
              .map((doc) => Schedule.fromFirestore(doc))
              .toList();
        });
  }
}
